We thank the reviewers for their thoughtful remarks, and will respond
to a few categories of concerns.


1. Related Work

We thank reviewers B and C for the pointers to extra related work.

We share a common goal with type error slicing, though the techniques
differ significantly. Error slicing involves a static analysis of the
typing data and presents multiple candidate error locations, possibly
ranked according to some heuristic. In contrast, we execute the program
and present an execution trace demonstrating the error. Gast's IFL 2004
paper is perhaps the most similar to ours as he produces a data flow
that would violate the typing rules.

Customizable type error messages along the lines of Heeren 2003,
Christiansen 2015, and Serrano Mena 2016 also addresses the issue of
poor type errors. The difference with our work is more pronounced, as
these techniques often rely on domain-specific knowledge to craft
high-quality error messages, whereas our approach is fully automatic but
ignorant of the application domain.

We will extend the Related Work section to reference all of these
techniques and papers.


2. Bias in Type Instantiation

In the `fac` example, asserting that `n` must be an int at the branch is
indeed biased. Our bias is towards the evaluation semantics of the
language, other techniques are biased by their traversal strategy or by
various heuristics.

We would argue, however, (as in Section 5.4) that our bias is more
natural as it is based on a concrete instance of the program crashing.
We will expand the relevant text to clarify this issue. 


3. Overloading / Type Classes

Overloaded operators are problematic for our approach. In reviewer C's
variant of `fac`, we would get stuck at the `if n <= m` test because `n`
and `m` are constrained to the same unknown type. Thus we do not know
how to instantiate them, and would fail to discover a witness. Our
benchmarks suggest this is rare in novice programs, but the issue would
be exacerbated if we ported the approach to Haskell, due to the
prevalence of type classes.

We will describe this issue in the Discussion section, and defer a
treatment of overloading to future work.


4. Scaling to Real-World Code

Our benchmarks are small programs as they were drawn from homework
submissions, the largest being around 200 LoC. It is quite possible
that our heuristic for compressing the trace based on function calls
would not suffice for larger programs, though there is a broad
literature on program slicing to draw from there. We will augment our
discussion of this threat to generality in the text.


5. Language Features

By "pure subset" of OCaml we mean polymorphic datatypes and records, and
we will clarify this in the text. We do not support references, modules,
or the object system.

It is true that we implicitly assume all types are inhabited in the
formalism, and that the generality theorem is weaker in the presence of
uninhabited types. We will clarify this in the text.
