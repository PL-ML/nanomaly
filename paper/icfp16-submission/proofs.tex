\section{Proofs for Section~\ref{sec:semantics}}
\label{sec:proofs}

\begin{proof}[Proof of Lemma~\ref{lem:force-inst}]
  By case analysis on the evaluation rules.
  %
  If $\ptype{\trace}{f} \neq \ptype{\trace'}{f}$ then,
  % one of the holes in $f$'s
  % argument must have been instantiated with a concrete value at the last step.
  by the definition of $\ptype{\trace}{f}$, $\tsu \neq \tsu'$, as \thole
  does not change.
  %
  % An examination of the rules shows that only place this happens is
  % in the second case of \forcesym.
  An examination of the rules shows that only \forcesym can update \tsu.


  Furthermore, an examination of \forcesym immediately shows that in the
  cases where \forcesym returns \stuck, \tsu\ is unmodified. Thus only
  \emph{successful} calls to \forcesym can change \tsu\ and, by
  extension, \ptype{\trace}{f}.

  % - narrow(leaf[t_1], t_2, \sigma, \theta)
  %   - t_1 != \alpha because E-Leaf always creates fresh \alpha
  %   - what aboue t_2? could mention \alpha in E-Node-*..

  % By case analysis on the evaluation rules. As above we are only
  % concerned with the sucessful steps, and can thus ignore the
  % \rulename{E-*-Bad} rules.

  % In each case we will show that only
  % the calls to \forcesym can change the partial input type of $f$.

  % \begin{description}
  % % \item[Case \reholegood] \hastype{\ehole}{\thole}, which is
  % %   alpha-equivalent to \typeof{\vhole{\thole}}, thus this step does not
  % %   change the partial type.
  % \item[Case \replusgood] Since narrowing succeeded on $v_1$ and $v_2$,
  %   they must have both either been ints or unconstrained holes.
  %   The only way the partial input type could have changed is if one or the
  %   other was a hole, and was instantiated by \forcesym.
  % \item[Case \rulename{E-If-Good-\{1,2\}}] Since narrowing succeeded on
  %   $v$, it must have either been a bool or an unconstrained hole.
  %   The only way the partial input type could have changed is if $v$ was a
  %   hole and was instantiated by \forcesym.
  % \item[Case \reappgood] Since narrowing succeeded on $v$, it must have
  %   either been a lambda or an unconstrained hole. The only way the
  %   partial input type could have changed is if $v$ was a hole and was
  %   instantiated by \forcesym.
  % \item[Case \releafgood] This rule does not call \forcesym, thus it
  %   cannot change the partial input type, and cannot have been applied.
  % \item[Case \renodegood] In this case the partial input type could have
  %   changed if any of $v_1$, $v_2$, or $v_3$ were unconstrained holes.
  %   Since both \forcesym calls succeeded \emph{and} the partial input
  %   type changed

  %   Since narrowing succeeded on $v_2$ and $v_3$,
  %   they must have both been trees or unconstrained holes

  %   \ES{come back to this, not entirely clear it
  %     holds as we might learn the element type from one of the subtrees}
  % \item[Case \rulename{E-Case-Good\{1,2\}}] Since narrowing succeeded on
  %   $v$, it must have either been a tree or an unconstrained hole.
  %   The only way the partial input type could have changed is if $v$ was a
  %   hole and was instantiated by \forcesym.
  % \end{description}
\end{proof}


\begin{proof}[Proof of Lemma~\ref{lem:refine-partial}]
  By case analysis on the evaluation rules.

  We can immediately discharge the $\rulename{E-*-Bad}$ rules as they
  result in the \stuck state, and by Lemma~\ref{lem:force-inst} we know
  that these rules cannot change \ptype{\trace}{f} at all.

  % and
  % an inspection of \forcesym shows that when \forcesym returns \stuck,
  % it does not modify \vsu or \tsu. Furthermore, \forcesym is the only
  % procedure that can modify the substitutions.

  % For the remainder of the rules we must
  % consider how they might affect both the input (by instantiating holes)
  % and output components of the partial type.

  % We will call a type hole \thole \emph{unconstrained} if applying the
  % current type substitution \subst{\tsu}{\thole} produces a type hole.

  \begin{description}
  \item[Case \replusgood] Both $v_1$ and $v_2$ successfully narrowed to
    \tint, so they must have either been ints or unconstrained
    holes. Thus partial input type compatibility is preserved.

    % \hastype{\eplus{v_1}{v_2}}{\thole} and
    % \hastype{n}{\tint}, so partial type compatibility of the output is
    % preserved.
  \item[Case \rulename{E-If-Good-\{1,2\}}] $v$ successfully narrowed to
    \tbool, so it must have either been a bool or an unconstrained hole.
    Thus partial input type compatibility is preserved.

    % \hastype{\eif{v}{e_1}{e_2}}{\thole}, which is compatible with any
    % type $e_1$ or $e_2$ might have, so partial type compatibility of the
    % output is also preserved.
  \item[Case \reappgood] $v_1$ successfully narrowed to \tfun, so it
    must have either been a lambda or an unconstrained hole, so partial
    input type compatibility is preserved.

    % \hastype{\eapp{v_1}{v_2}}{\thole}, which is compatible with any type
    % $e$ might have, so partial type compatiblity of the output is
    % preserved.
  \item[Case \releafgood] This rule does not call \forcesym, so this
    step cannot affect partial input type compatibility.

    % \eleaf steps to \vleaf{\thole} with a fresh \thole,
    % but \hastype{\eleaf}{\ttree{\thole}}, so partial type compatibility
    % of the output is preserved.
  \item[Case \renodegood]
    % $v_1$ successfully narrowed to $t$, so it must
    % have already been a $t$ or an unconstrained hole. Likewise,
    $v_2$ and $v_3$ successfully narrowed to \ttree{t}, so they must have
    already been \ttree{t}'s or unconstrained holes. Thus partial input type
    compatibility is preserved.
    %
    $v_1$ is not narrowed, but if it \vhole{\thole} we may constrain
    \thole by narrowing $v_2$ or $v_3$. However, partial input type
    compatibility must still be preserved as the calls to \forcesym will
    only succeed if \thole is either completely unconstrained (in which
    case compatibility is trivial), or if it were constrained to a type
    that is compatible with the types of $v_2$ and $v_3$.

    % so if it was a hole it would not be
    % instantiated here, thus it cannot affect partial input type compatibility.

    % \hastype{\enode{v_1}{v_2}{v_3}}{\ttree{\thole}}, with a fresh \thole
    % and\\ \hastype{\vnode{t}{v_1}{v_2}{v_3}}{\ttree{t}}. But
    % \tcompat{\thole}{\ttree{t}} because we can just map \thole to
    % \ttree{t} (as \thole is fresh), so partial type compatibility of the
    % output is preserved.
  \item[Case \rulename{E-Case-Good-\{1,2\}}] $v$ successfully narrowed to
    \ttree{\thole} so it must have either been a tree or an
    unconstrained hole, so partial input type compatibility is
    preserved.

    % \hastype{\ecase{v}{e_1}{x_1}{x_2}{x_3}{e_2}}{\thole}, which is
    % compatible with any type $e_1$ and $e_2$ might have, so partial type
    % compatibility of the output is preserved.
  % \item[Case \reholegood] \hastype{\ehole}{\thole}, with a fresh \thole,
  %   and \hastype{\vhole{\thole}}{\thole}, but a fresh hole is compatible
  %   with anything, so partial input type compatibility is preserved.
  \end{description}
\end{proof}

% \begin{proof}[Proof of Lemma~\ref{lem:refine-partial}]
%   By case analysis on the evaluation rules. We can immediately discharge
%   the $\rulename{E-*-Bad}$ rules as they result in the \stuck state.
%   \begin{description}
%   \item[Case \replusgood] \hastype{\eplus{v_1}{v_2}}{\thole} and
%     \hastype{n}{\tint}, so partial type compatibility is preserved.
%   \item[Case \rulename{E-If-Good\{1,2\}}]
%     \hastype{\eif{v}{e_1}{e_2}}{\thole}, which is compatible with any
%     type $e_1$ or $e_2$ might have.
%   \item[Case \reappgood] \hastype{\eapp{v_1}{v_2}}{\thole}, which is
%     compatible with any type $e$ might have.
%   \item[Case \eleaf] \eleaf steps to \vleaf{\thole} with a fresh \thole,
%     but \hastype{\eleaf}{\ttree{\thole}}, so partial type compatibility
%     is preserved.
%   \item[Case \renodegood]
%     \hastype{\enode{v_1}{v_2}{v_3}}{\ttree{\thole}}, with a fresh \thole
%     and \hastype{\vnode{t}{v_1}{v_2}{v_3}}{\ttree{t}}. But
%     \tcompat{\thole}{\ttree{t}} because we can just map \thole to
%     \ttree{t} (as \thole is fresh), so partial type compatibility is
%     preserved.
%   \item[Case \rulename{E-Case-Good\{1,2\}}]
%     \hastype{\ecase{v}{e_1}{x_1}{x_2}{x_3}{e_2}}{\thole}, which is compatible
%     with any type $e_1$ and $e_2$ might have.
%   \item[Case \reholegood] \hastype{\ehole}{\thole}, with a fresh
%     \thole, and \hastype{\vhole{\thole}}{\thole}, but a fresh hole is
%     compatible with anything, so compatibility is preserved.
%   \end{description}
% \end{proof}

\begin{proof}[Proof of Lemma~\ref{lem:k-stuck}]
  We can construct $v$ from $\trace$ as follows.
  %
  Let
  $$
  \trace_i = \triple{\eapp{f}{\vhole{\thole}}}{\emptysu}{\emptysu},
             \ldots,
             \triple{e_{i-1}}{\vsu_{i-1}}{\tsu_{i-1}},
             \triple{e_{i}}{\vsu_{i}}{\tsu_{i}}
  $$
  be the shortest prefix of $\trace$ such that
  $\tincompat{\ptype{\trace_i}{f}}{t}$.
  %
  We will show that $\resolve{\vhole{\thole}}{\vsu_{i-1}}$
  must contain some other hole $\ehole'[\thole']$
  whose type $\thole'$ is constrained
  at step $i$.
  %
  Furthermore, $\thole'$ is constrained in such a way that
  $\vincompat{\resolve{\vhole{\thole}}{\vsu_{i}}}{t}$.
  %\ES{need to connect \ptype{\trace{i}}{f} and \resolve{\vhole{\thole}}{\vsu_i}}
  %
  Finally, we will show that if we had instantiated $\ehole'$ with a
  value such that
  $\vcompat{\resolve{\vhole{\thole}}{\vsu_{i}}}{t}$, the current
  step would have gotten $\stuck$.

  % By Lemma~\ref{lem:fixme} we know that
  % $\vcompat{\resolve{\vhole{\thole}}{\vsu}}{\resolve{\thole}{\tsu}}$.
  %
  By Lemma~\ref{lem:vsu-ext} we know that
  $\vsu_{i} = \vsu_{i-1}[\ehole_1 \mapsto v_1] \ldots [\ehole_n \mapsto v_n]$.
  %
  We will assume, without loss of generality, that
  $\vsu_{i} = \vsu_{i-1}[\ehole' \mapsto v']$.

  Next, we introduce a notion of \emph{value contexts}, defined
  analogously to evaluation contexts.
  %
  $$
    V ::= \bullet \spmid \vnode{t}{V}{v}{v} \spmid \vnode{t}{v}{V}{v} \spmid \vnode{t}{v}{v}{V}
  $$
  %
  Since $\vsu_{i-1}$ and $\vsu_{i}$ differ only in $\ehole'$ but the resolved
  values differ,
  $\resolve{\vhole{\thole}}{\vsu_{i-1}} = \vcompat{\invctx{\ehole'[\thole']}}{t}$
  and
  $\resolve{\vhole{\thole}}{\vsu_{i}} = \vincompat{\invctx{v'}}{t}$.
  %
  Now, consider any value $u$ such that $\vcompat{\invctx{u}}{t}$,
  we show by case analysis on the evaluation relation that
  $\invctx{u}$ could not make progress at this step, and thus
  $\steps{\eapp{f}{\invctx{u}}}{\emptysu}{\emptysu}{\stuck}{\vsu'}{\tsu'}$.
  %
    \begin{description}
    \item[Case \replusgood:]
      %
      Here we \forcesym $v_1$ and $v_2$ to $\tint$, so the first case of
      \forcesym must apply\\ ($\force{n}{\tint}{\vsu}{\tsu}$ cannot apply
      as it does not change $\vsu$).
      %
      In particular, we must have extended $\vsu$ with
      $[\ehole' \mapsto v']$ where $v'$ is a $\tint$.
      %
      Let $u$ be any concrete value that is incompatible with $\tint$,
      $\force{u}{\tint}{\vsu}{\tsu} = \triple{\stuck}{\vsu}{\tsu}$.
    \item[Case \rulename{E-Plus-Bad\{1,2\}}:]
      %
      These cases cannot apply as \forcesym does not update \vsu\ when
      it returns \stuck.
    \item[Case \rulename{E-If-Good\{1,2\}}:]
      %
      Here we \forcesym $v$ to $\tbool$, so the first case of \forcesym
      must apply ($\force{b}{\tbool}{\vsu}{\tsu}$ cannot apply as it
      does not change $\vsu$).
      %
      In particular, we must have extended $\vsu$ with
      $[\ehole' \mapsto v']$ where $v'$ is a $\tbool$.
      %
      Let $u$ be any concrete value that is incompatible with $\tbool$,
      $\force{u}{\tbool}{\vsu}{\tsu} = \triple{\stuck}{\vsu}{\tsu}$.
    \item[Case \reifbad:]
      %
      This case cannot apply as \forcesym does not update \vsu\ when
      it returns \stuck.
    \item[Case \reappgood:]
      %
      Here we \forcesym $v$ to $\tfun$, so the first case of \forcesym
      must apply ($\force{\efun{x}{e}}{\tfun}{\vsu}{\tsu}$ cannot apply as it
      does not change $\vsu$).
      %
      In particular, we must have extended $\vsu$ with
      $[\ehole' \mapsto v']$ where $v'$ is a $\tfun$.
      %
      Let $u$ be any concrete value that is incompatible with $\tfun$,
      $\force{u}{\tfun}{\vsu}{\tsu} = \triple{\stuck}{\vsu}{\tsu}$.
    \item[Case \reappbad:]
      %
      This case cannot apply as \forcesym does not update \vsu\ when
      it returns \stuck.
    \item[Case \releafgood:]
      %
      This case cannot apply as it does not update \vsu.
    \item[Case \renodegood:]
      %
      Here we \forcesym $v_2$ and $v_3$ to $\ttree{t}$, so the first
      case of \forcesym must apply
      (neither\\ $\force{\vleaf{\ttree{t_1}}}{\ttree{t_2}}{\vsu}{\tsu}$
       nor\\ $\force{\vnode{\ttree{t_1}}{v_1}{v_2}{v_3}}{\ttree{t_2}}{\vsu}{\tsu}$
       can apply as they do not change $\vsu$).
      %
      In particular, we must have extended $\vsu$ with
      $[\ehole' \mapsto v']$ where $v'$ is a $\ttree{t}$.
      %
      Let $u$ be any concrete value that is incompatible with $\ttree{t}$,
      $\force{u}{\ttree{t}}{\vsu}{\tsu} = \triple{\stuck}{\vsu}{\tsu}$.
      %
      \ES{this seems too easy...}
    \item[Case \renodebadone:]
      %
      This case cannot apply as \forcesym does not update \vsu\ whe
      it returns \stuck.
    \item[Case \renodebadtwo:]
      %
      In this case $\force{v_2}{\ttree{t}}{\vsu_1}{\tsu_1}$ can update
      \vsu, but $\force{v_3}{\ttree{t}}{\vsu_2}{\tsu_2}$ can not, as the
      latter returns \stuck.
      %
      For the former case we can apply the same reasoning as for
      \renodegood to derive a value $u$ that will cause stuckness.
    \item[Case \rulename{E-Case-Good\{1,2\}}:]
      %
      Here we \forcesym $v$ to $\ttree{\thole}$, so the first case of \forcesym
      must apply
      (neither\\ $\force{\vleaf{\ttree{t_1}}}{\ttree{t_2}}{\vsu}{\tsu}$
       nor\\ $\force{\vnode{\ttree{t_1}}{v_1}{v_2}{v_3}}{\ttree{t_2}}{\vsu}{\tsu}$
       can apply as they do not change $\vsu$).
      %
      In particular, we must have extended $\vsu$ with
      $[\ehole' \mapsto v']$ where $v'$ is a $\ttree{\thole}$.
      %
      Let $u$ be any concrete value that is incompatible with $\ttree{\thole}$,
      $\force{u}{\ttree{\thole}}{\vsu}{\tsu} = \triple{\stuck}{\vsu}{\tsu}$.
    \end{description}
  % \begin{description}
  % \item [Case \tincompat{t}{s_{\trace'}}:]
  %   The inductive hypothesis applies.
  % \item [Case $\tcompat{t}{s_{\trace'}}$ but $\tincompat{t}{s_{\trace}}$:]
  %   Since $\tcompat{t}{s_{\trace'}}$ but $\tincompat{t}{s_{\trace}}$ we know
  %   that $s_{\trace'} \neq s_{\trace}$, and
  %   by Lemma~\ref{lem:force-inst} we know that we must have
  %   successfully called \forcesym at step $k$.
  %   %
  %   Lemma~\ref{lem:refine-partial} tells us
  %   $\tcompat{s_{\trace'}}{s_{\trace}}$, which means we must have
  %   specifically narrowed $s_{\trace'}$ to a type incompatible with $t$.
  %   %
  %   We show by case analysis of the evaluation rules that narrowing to
  %   $t$ instead cannot succeed.

  %   Again we can immediately discharge the \rulename{E-*-Bad}
  %   rules as they get stuck, proving the consequent.

  %   In the \rulename{E-*-Good} rules we must consider where a hole might
  %   appear in the expression, and what would happen if we replaced the
  %   hole with the value $w$.
  %   %
  %   \begin{description}
  %   % \item[Case \reholegood:] \thole is compatible with any type, which
  %   %   contradicts the premise that \tincompat{t}{s_{\trace}}.
  %   \item[Case \replusgood:] The hole may appear in either $v_1$ or
  %     $v_2$. We \forcesym $v_1$ and $v_2$ to have type \tint, but we
  %     assumed that $w$ has a type that is incompatible with \tint, thus
  %     if we replace the hole with $w$, \forcesym must fail on either
  %     $v_1$ or $v_2$.
  %   \item[Case \rulename{E-If-Good-\{1,2\}}:]

  %     By Lemma~\ref{lem:new-lem} we know that $\vhole{\thole} \in v$ and
  %     $[\thole \mapsto t] \in \theta'$. Thus we must have taken the first
  %     case of \forcesym, so $v = \vhole{\thole}$.

  %     % By Lemma~\ref{lem:force-inst} we know that this step must have
  %     % called \forcesym on $\vhole{\thole}$, narrowing it to have type
  %     % \tbool, thus $\ptype{\trace}{f} = \tbool$. But we assumed
  %     % $\vincompat{w}{\tbool}$, thus \forcesym cannot succeed if we
  %     % replace $\vhole{\thole}$ with $w$.
  %     % Here we \forcesym $v$ to have type
  %     % \tbool, but we assumed that $v$ has a type that is incompatible with
  %     % \tbool, thus \forcesym must fail.
  %   \item[Case \reappgood:] Here we \forcesym $v$ to have type
  %     \tfun, but we assumed that $v$ has a type that is incompatible with
  %     \tfun, thus \forcesym must fail.
  %   \item[Case \releafgood:] This rule does not call \forcesym, so by
  %     Lemma~\ref{lem:force-inst} it cannot have applied.
  %   \item[Case \renodegood:] There are two cases we must consider here,
  %     the sub-trees and the value at the node.

  %     Consider first the sub-trees. We \forcesym $v_2$ and $v_3$ to have
  %     type \ttree{t}, but we assumed $v$ has some type incompatible with
  %     \ttree{t}, so one of the \forcesym calls must fail.

  %     Next consider the value $v_1$. Even though we do not \forcesym
  %     $v_1$ directly, we seed the \forcesym calls with $\typeof{v_1}$,
  %     which will then fail if $\typeof{v_1}$ is incompatible with the
  %     types of the sub-trees, which our assumption tells us must be the
  %     case.
  %   \item[Case \rulename{E-Case-Good-\{1,2\}}:] Here we \forcesym $v$ to
  %     have type \ttree{\thole}, but we assumed that $v$ has a type that
  %     is incompatible with \ttree{\thole}, thus \forcesym must fail.
  %   \end{description}
  % \end{description}
\end{proof}

% \begin{proof}[Proof of Theorem~\ref{thm:soundness}]
% Suppose $\trace$ witnesses that $f$ gets stuck,
% and let $t = \ptype{\trace}{f}$.
% We show that \emph{all} types $s$ have stuck-inducing
% values by splitting cases on whether the type is
% compatible with $t$. %the partial type upto $\trace$.
% %
% \begin{description}
% \item [Case \tcompat{s}{t}:]
%   Let $\trace = \triple{\eapp{f}{\vhole{\thole}}}{\emptysu}{\emptysu},\ldots,\triple{\stuck}{\vsu}{\tsu}$.
%   %
%   The value $v = \resolve{\ehole}{\vsu}$ demonstrates that
%   $\eapp{f}{v}$ gets stuck.
% \item [Case \tincompat{s}{t}:] By Lemma~\ref{lem:k-stuck}, we can derive
%   a $v$ from $\trace$ such that \hastype{v}{t} and $\eapp{f}{v}$ gets
%   stuck.
%   % \ES{do we need to say anythign else?}
% \end{description}
% \end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
