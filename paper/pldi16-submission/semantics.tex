
\begin{itemize}
\item how do we run ill-typed programs?
\item for a lang like ocaml, dynamic semantics are independent of static
  semantics, just lambda calculus. so no problem to run ill-typed
  program
\item but what about functions? what type of arguments should we pass? consider

\begin{lstlisting}
let f x = 
  let y = 1 + x in
    1. +. y
\end{lstlisting}

does \texttt{f} take an int, float, string? int and float are both
somewhat plausible, but string or anything else is ``clearly'' bogus. so
we cannot provide \emph{completely arbitrary} inputs to
\texttt{f}. Instead, we call \texttt{f} with a \emph{hole}, written
\ehole{}, which is a placeholder for a value whose type we have not
yet determined. As we execute the program, we instantiate holes with
concrete values as demanded by the primitive operations in the
program. For example, the hole we pass to f will be instantiated to an
int when we reach the \lstinline{1 + x} term. Thus, y will be an int as
well, and the program will get stuck at \lstinline{1. +. y}. \ES{this
  reads more like overview text..}

% \item values are tagged with their types, just like ``untyped'' langs
% \item special ``hole'' value whose type is not yet known, used for function args
% \item on-the-fly unification to determine ``correct'' type for holes
\end{itemize}

Next, we formalize our search for witnesses to type-errors.
%
We present the syntax and operational semantics of \lang -- a simple
lambda calculus with integers and booleans, extended with our notion of
holes -- as well as our search algorithm.
%
We prove that our system \emph{soundly} finds witnesses, \ie if we find
a witness then there is no possible typing for the input program.
%
\subsection{Syntax}
\label{sec:syntax}
\input{syntax.tex}
%
Figure~\ref{fig:syntax} describes the syntax of \lang, a simple lambda
calculus with numbers and booleans.
%
As we are specifically interested in
programs that \emph{do} go wrong, we include an explicit \stuck state in
our syntax.
%
\paragraph{Holes}
\label{sec:holes}
The main novelty in our system is the notion of a ``hole'', written
\ehole{}, which represents an uninstantiated value.
%
Importantly, we do not even know what type the value should have.
%
Holes may also appear in types, where they may be thought of as type
variables that we will not generalize over.
%
\subsection{Semantics}
\label{sec:semantics}
\input{operational.tex}
%
Figure~\ref{fig:operational} describes the small-step contextual
reduction semantics for \lang.
%
We write \stepi{j}{e}{\su}{e'}{\su'} if there exist $e_1,\ldots,e_j$ such that
$e$ is $e_1$, $e'$ is $e_j$ and $\forall i,j, 1 \leq i < j$, we have
\step{e_i}{\su_i}{e_{i+1}}{\su_{i+1}}.
%
We write \steps{e}{\su}{e'}{\su'} if there exists some (finite) $j$ such that
$\stepi{j}{e}{\su}{e'}{\su'}$.
%
The evaluation relation is parameterized by a pair of \forcesym and
\gensym functions that handle runtime type-checking and instantiation of
holes respectively.
%
The relation must also maintain a substitution \su, mapping holes to
concrete values, so that we do not instantiate the same hole with
different values in different contexts, and so that we can report a
concrete witness to any discovered type errors.

Note that each primitive reduction step -- addition, if-elimination, and
function application -- uses \forcesym to ensure that values have the
appropriate type (and that holes are instantiated) before continuing the
computation.
%
Additionally, beta-reduction \emph{does not} type-check its argument, it
only ensures that the value being applied is a function.
%
\begin{thm}
\label{thm:all-reduce}
  Every closed expression $e$ reduces to a value $v$ (which may be \stuck).
  \ES{do we really need to state this, or is it obvious?}
\end{thm}
% \begin{proof}%[Proof of \autoref{thm:all-reduce}]
%   Simple induction on the evaluation relation.
% \end{proof}
%
\subsection{Soundness}
\label{sec:soundness}
We now show that our evaluation relation conservatively instantiates
holes, \ie if, given a function $f$, we report that 
$\steps{\eapp{f}{\ehole{}}}{\emptysu}{\stuck}{\su}$,
then for any type $\tfun{s}{t}$ you assign to $f$, there exists an input \hastype{v}{s} such that
$\steps{\eapp{f}{v}}{\emptysu}{\stuck}{\su}$.

We can think of the evaluation of \eapp{f}{\ehole{}} as
computing a \emph{partial type} -- a type that may contain holes -- for
$f$. We can extract this type from the result of evaluation as follows.
%
\begin{defn}
\label{defn:partial-type}
  If \stepi{i}{\eapp{f}{\ehole{}}}{\emptysu}{e}{\su}, then the $i$th
  \emph{partial type} of f, written \ptype{i}{f},
  is \tfun{\typeof{\subst{\su}{\ehole{}}}}{\typeof{e}}.

  We will omit the subscript when we wish to refer to the final partial
  type. \ES{need to define typeof..}
\end{defn}
%
We also define a compatibility relation between types.
%
\begin{defn}
\label{defn:type-compat}
  A type $s$ is \emph{compatible} with a type $t$, written \tcompat{s}{t}, if
  $\exists \su.\ t = \subst{\su}{s} \lor s = \subst{\su}{t}$.
\end{defn}
%
Given these two definitions, we show that each evaluation step
refines the partial type of $f$.
%
\begin{lem}
\label{lem:refine-partial}
  For all $k$, \tcompat{\ptype{k}{f}}{\ptype{k+1}{f}}.
\end{lem}
%
\begin{lem}
\label{lem:force-inst}
  For all $k$, if $\ptype{k}{f} \neq \ptype{k+1}{f}$, then \forcesym must
  have been called at step $k+1$.
\end{lem}
\begin{proof}
  By case analysis on the evaluation rules. 
  % 
  If $\ptype{k}{f} \neq \ptype{k+1}{f}$ then one of the holes in $f$'s
  argument must have been instantiated with a concrete value at step
  $k+1$.
  %
  An examination of the rules shows that only place this happens is 
  in the first case of \forcesym.
\end{proof}
%
Finally, we show that any value that is not compatible with the $k$th
partial type of $f$ will cause $f$ to get stuck in \emph{at most} $k$
steps.
%
\begin{lem}
\label{lem:k-stuck}
  For any \hastype{v}{t} that is not compatible with
  the input of \ptype{k}{f}, \stepi{k}{\eapp{f}{v}}{\emptysu}{\stuck}{\su}.
\end{lem}
\begin{proof}
  By induction on $k$.
  
  Let $s_k = \ptype{k}{f}$. Suppose \hastype{v}{\tincompat{t}{s_{k+1}}}, we
  will show that \stepi{k+1}{\eapp{f}{v}}{\emptysu}{\stuck}{\su}.
  \begin{description}
  \item[Case \tincompat{t}{s_k}:] 
    The inductive hypothesis applies.
  \item[Case \tcompat{t}{s_k} but \tincompat{t}{s_{k+1}}:] 
    By Lemma~\ref{lem:force-inst} we must have called \forcesym at step
    $k+1$. A case analysis of the applicable rules shows that \forcesym
    cannot have succeeded.
  \end{description}
\end{proof}
%
Now we can prove our soundness theorem.
%
\begin{thm}
\label{thm:soundness}
  For any function $f$, if \steps{\eapp{f}{\ehole{}}}{\emptysu}{\stuck}{\su},
  then $\forall t. \exists \hastype{v}{t}. \steps{\eapp{f}{v}}{\emptysu}{\stuck}{\su}$.
\end{thm}
\begin{proof}
  Let $\tfun{s}{\_} = \ptype{}{f}$.
  \begin{description}
  \item[Case \tcompat{s}{t}:] Our witness is already valid.
  \item[Case \tincompat{s}{t}:] We can apply Lemma~\ref{lem:k-stuck} and
    use \emph{any} \hastype{v}{t} as a witness for $f$.
  \end{description}
\end{proof}

% \item values are tagged with their types, just like ``untyped'' langs
% \item special ``hole'' value whose type is not yet known, used for function args
% \item on-the-fly unification to determine ``correct'' type for holes
% \end{itemize}

% Algorithm:
%   Input: ML Program (let f1 = e1 in let f2 = e2 in ... e)
%   Output: 'safe' or 'fn v1 .. vn' where 'fn v1 .. vn' gets stuck

