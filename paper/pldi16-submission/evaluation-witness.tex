\section{Evaluation: Recasting Type Errors as Runtime Errors}
\label{sec:eval-witness}
%
The immediate question is ``What fraction of type errors admit
witnesses?''
%
To answer this question we implemented a prototype of our search
procedure for the pure subset of \ocaml, \ie \lang extended with
algebraic datatypes and records. 
%
In our implementation we instantiated \gensym with a simple random
generation of values, which we will show is more than sufficient for the
majority of type errors.
%
We evaluated our implementation of two sets of known-bad programs, \ie
programs that were rejected by the \ocaml compiler because of a type
error.
%
The first dataset comes from the Spring 2014 undergraduate Programming
Languages course at UC San Diego (IRB \#XXXXX). 
%
We recorded each interaction with the \ocaml top-level system over the
course of the first three assignments, from which we extracted XXXX
distinct, ill-typed \ocaml programs.
%
The second dataset -- widely used in the literature -- comes from a
similar course at the University of Washington~\cite{XXXXX}, from which
we extracted XXXX ill-typed programs.

We ran our search algorithm on each program with the entry point set to
the function that \ocaml had identified as containing a type error. 
%
Due to the possibility of non-termination we set a limit on the number
of reductions to perform, increasing in 1,000-step increments from 1,000
steps to 10,000 steps total.
%
We also added a na\"ive check for infinite recursion; at each recursive
function call we check whether the new arguments are identical to the
current arguments.
%
If so, the function cannot possibly terminate and we report an error.
%
While not a \emph{type error}, infinite recursion is still a clear bug
in the program, and thus valuable feedback for the user.

\begin{figure}[t]
  \centering

  \includegraphics[width=\linewidth]{coverage.png}
  \includegraphics[width=\linewidth]{distrib_seminal.png}

% \begin{tikzpicture} 
% \begin{axis}[
%   title=Cumulative Coverage,
%   ybar interval,
%   xticklabel=
% \pgfmathprintnumber\tick--\pgfmathprintnumber\nexttick
% ]
%     \addplot+[hist={bins=3, cumulative}]
%         table[row sep=\\,y index=0] {
%         data\\
%         1\\ 2\\ 1\\ 5\\ 4\\ 10\\
%         7\\ 10\\ 9\\ 8\\ 9\\ 9\\
%     };
% \end{axis}
% \end{tikzpicture}

% \begin{tikzpicture} \begin{axis}[
%   title=Result Distribution,
% %  ybar interval,
% %  symbolic hist/data coords={S,U,B,O,D,T},
%   hist/symbolic coords={S,U,B,O,D,T},
% %  xticklabel={[\tick--\nexttick[}],
% ]
%     \addplot+[hist={bins=3}]
%         table[row sep=\\,y index=0] {
%         data\\
%         S\\ S\\ U\\
%     };
% \end{axis}
% \end{tikzpicture}

  Have a table or graph! \ES{graph of cumulative errors per timeout? \ie
    monotonically increasing, with a cap of 90\% or so}
\caption{Experimental results}
\label{fig:results-witness}
\end{figure}

\paragraph{Results}
\label{sec:results-witness}
The results of our experiments are summarized in
Figure~\ref{fig:results-witness}.
%
In both datasets our tool was able to find a witness for at least XX\%
of the programs.
%
Interestingly, while the vast majority of witnesses corresponded to a
type-error, as expected, X\% triggered an unbound variable error and X\%
triggered an infinite recursion error.
%
XX programs were deemed safe and XX timed out even at 10,000 steps, \ie
we could not provide any useful feedback for XX\% of the total programs.
%
While a more advanced search procedure, \eg dynamic-symbolic execution,
could likely trigger more of the type errors, our experiments show that
type errors are coarse enough (or that novice programs are \emph{simple}
enough) that these techniques are not necessary.



% \begin{itemize}
% \item benchmarks: our data + seminal data
% \item both cases: \textbf{random} search sufficient to trigger runtime crash in 80\% of programs
% \item how many of the ``safe'' programs are actually safe??
% \end{itemize}
