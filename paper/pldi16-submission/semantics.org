* Type-Carrying

** Syntax

#+BEGIN_SRC
E ::= V
   |  E E
   |  if E then E else E
   |  E + E

V ::= N
   |  B
   |  \X. E
   |  _
   |  stuck T T

N ::= 0..

B ::= true | false

T ::= bool
   |  nat
   |  T -> T
#+END_SRC

- probably want to add datatypes
- do we want to deal with env-passing in the description? or leave as implementation detail?

** Semantics

*** relies on =force= and =gen= helpers

#+BEGIN_SRC
gen : T -> V
gen int      = N
gen bool     = B
gen (_ -> t) = \x. gen t

force : V -> T -> V
force N int
  = N
force N t
  = stuck int t
force B bool
  = B
force B t
  = stuck bool t
force (\x. e) (t1 -> t2)
  = \x -> e
force (\x. e) t
  = stuck (T -> T) t
force _ t
  = gen t
#+END_SRC

*** Important single-step rules

- note that we can get only get stuck at "primitive" operations
- beta-reduction *does not* type-check the argument

**** nats
#+BEGIN_SRC
n1 = force v1 nat
n2 = force v2 nat
n  = n1+n2
-----------------------------------------------
v1 + v2
~>
n

stuck t1 t2 = force v1 nat
--------------------------
v1 + v2
~>
stuck t1 t2

stuck t1 t2 = force v2 nat
--------------------------
v1 + v2
~>
stuck t1 t2
#+END_SRC

**** bools
#+BEGIN_SRC
true = force v1 bool
--------------------
if v1 then e1 else e2
~>
e1

false = force v1 bool
---------------------
if v1 then e1 else e2
~>
e2

stuck t1 t2 = force v1 bool
---------------------------
if v1 then e1 else e2
~>
stuck t1 t2
#+END_SRC

**** lambdas
#+BEGIN_SRC
(\x. e) = force v1 (T -> T)
-----------------------------
v1 v2
~>
e[x/v2]

stuck t1 t2 = force v1 (T -> T)
-------------------------------
v1 v2
~>
(stuck t1 t2) v2
#+END_SRC

**** `stuck` bubbles up
#+BEGIN_SRC
if stuck t1 t2 then e1 else e2
~>
stuck t1 t2

stuck t1 t2 + e
~>
stuck t1 t2

e + stuck t1 t2
~>
stuck t1 t2

(stuck t1 t2) v
~>
stuck t1 t2
#+END_SRC

**** other rules
#+BEGIN_SRC
e1 ~> e2
--------
if e1 then e3 else e4
~>
if e2 then e3 else e4

e1 ~> e2
--------
e1 + e3
~>
e2 + e3

e1 ~> e2
--------
v + e1
~>
v + e2

e1 ~> e2
--------
e1 e3
~>
e2 e3
#+END_SRC


** Search Algorithm

*** Input
sequence of binders
#+BEGIN_SRC
let x1 = e1
let x2 = e2
...
let xn = en
#+END_SRC

*** Output
either

1. expression =e1 e2 .. en= such that
#+BEGIN_SRC
e1 e2 .. en ~>* stuck t1 t2
#+END_SRC

2. =SAFE= if no witness found

*** Outline

#+BEGIN_SRC haskell
-- | transitive small-step evaluation.
-- returns final value and mapping from holes to concrete values
eval :: E -> (V, Subst)

subst :: Subst -> [V] -> [V]

apply :: V -> [V] -> E

data Result = Safe | Unsafe E

check :: [E] -> Result
-- FIXME: the treatment of the input binders is super hand-wavy,
-- the syntax doesn't even mention `let` binders
check bnds = fillInLams (last bnds) []
  where
  fillInLams f args = case eval (apply f args) of
    ([[\x. e]], _)        -> fillInLams f (args `snoc` [[_]])
    ([[stuck t1 t2]], su) -> Unsafe (apply f (subst su args))
    ([[v]], _)            -> loop 1 f args

  loop n f args
    | n == numTries = Safe
    | otherwise     = case eval (apply f args) of
                        ([[stuck t1 t2]], su)
                          -> Unsafe (apply f (subst su args))
                        _ -> loop (n+1) f args
#+END_SRC

* Notes
- HOW DO YOU FORMALIZE "no false positives"??

- make a lattice of types?
  - what is the edge relation?

- failing "as late as possible"
  - given a path through CFG that crashes at location 't'
  - there is no input that goes beyond 't'
  - t < t'
